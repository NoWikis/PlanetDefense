using UnityEngine;
using System.Collections;



// Controls basic asteroid appearance and behavior
// TODO: determine escape velocity and remove if too far
// TODO: Collide with projectiles
public class AsteroidBehavior : MonoBehaviour {

	public float mass = 100;
	float baseMass = 60;
	Rigidbody  physicsBase;
	Mesh mesh;
	int numSpokes;
	Health health;


	// Controls how big the asteroids are generally
	float scaleMultiplier = 1f;


	// Mesh generation variables
	public int minSpokes = 4;
	public int maxSpokes = 12;
	public float spokeHeightMin = 1f; 
	public float spokeHeightMax = 1f;

	


	void Awake() {
		physicsBase = GetComponent<Rigidbody>();
		mesh = GetComponent<MeshFilter>().mesh;
		health = GetComponent<Health>();
		health.registerDamageCallback(OnHurt);
	}



	// Use this for initialization
	void Start () {
		numSpokes = (int)Random.Range(minSpokes, maxSpokes);

		physicsBase.mass = mass;
		generateMesh();


		transform.localScale  = scaleMultiplier*transform.localScale*(mass / baseMass);
	}
	
	// Update is called once per frame
	void Update () {
	
		//foreach(Vector3 v in mesh.vertices) {
		//	Debug.DrawLine(transform.position,
		//	               transform.position + v, new Color(255, 255, 0, 255));
		//}



		if (health.isDead()) {
			Destroy (gameObject);
		}

	}













	/* Collisions */
	
	void OnCollisionEnter(Collision other) {
		if (other.gameObject.tag != "Projectile") return;
		health.takeDamage(10);
	}
	
	void OnHurt(GameObject health) {
		Debug.Log (health.GetComponent<Health>().current());
	}























	/* Mesh generation */

	// Generates the asteroid's random mesh
	void generateMesh() {

		mesh.Clear ();

		Vector3 [] newVertices = generateVertices(
			numSpokes,
			spokeHeightMin,
			spokeHeightMax

		);


		mesh.vertices  = newVertices;
		mesh.triangles = generateTriangles(newVertices.Length-1);
		mesh.uv =        generateTexCoords();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();

		// If you want true collisions, consider a MeshCollider, but be aware that Unity hates flat meshes
		//GetComponent<MeshCollider>().sharedMesh = mesh;

		GetComponent<SphereCollider>().radius = getAverageRadius();




		// Optional, set the outline child object line renderer to be the border's highlights
		setOutline();

	}
	 

	// Generates an array of vertices that surround the centerpoint 0, 0
	// in a clockwise fashion. The points are placed uniformly around 0,0
	// at a random distance from minHeight to maxHeight. The length of the 
	// output Vertexd list is always 1 + numberOfPoints and the first element
	// is always 0, 0

	Vector3[] generateVertices(int numberOfDivisions, float minHeight, float maxHeight) {
		Vector3[] outVertices = new Vector3[numberOfDivisions+1];
		outVertices[0] = new Vector3(0, 0, 0);

		for (int i = 1; i < numberOfDivisions+1; ++i) {
			outVertices[i] = new Vector3(0, Random.Range (minHeight, maxHeight), 0);
			outVertices[i] = Quaternion.Euler(0, 0, (360.0f / (float)(numberOfDivisions))*i) * outVertices[i];

		}


		return outVertices;
	}


	// Generates triangles around the center based around the assumption that 
	// the vertices were generated by the generateVertices function
	int[] generateTriangles(int numVertices) {
		int[] tris = new int[numVertices*3];
		int vertexIndex = 1;

		for(int i = 0; i < numVertices; ++i) {
			tris[(i*3)+ 2] = 0;
			tris[(i*3)+ 1] = vertexIndex;
			tris[(i*3)+ 0] = vertexIndex+1;


			++vertexIndex;

		}

		tris[tris.Length-3] = 1;

		return tris;
	}


	// Generate proper texture coordinates based on vertices
	Vector2[] generateTexCoords() {
		Vector2[] outV = new Vector2[mesh.vertices.Length];
		for(int i = 0; i < mesh.vertices.Length; ++i) {
			outV[i] = new Vector2(mesh.vertices[i].x, mesh.vertices[i].y);
		}
		return outV;

	}



	// Returns the average distances of all the meshes vertices from the center
	float getAverageRadius() {
		float avg = 0;
		for(int i = 1; i < mesh.vertices.Length; ++i) {
			avg += Vector3.Distance(Vector3.zero, mesh.vertices[i]);
		}
		return avg /= mesh.vertices.Length - 1;
	}


	void setOutline() {
		LineRenderer outline = GetComponentInChildren<LineRenderer>();
		if (outline) {
			outline.SetVertexCount(mesh.vertices.Length);
			outline.SetWidth(.03f, .03f);
			for(int i = 1; i < mesh.vertices.Length; ++i) {
				outline.SetPosition(i-1, new Vector3(0, 0, -1) + mesh.vertices[i]);
				
			}

			outline.SetPosition(mesh.vertices.Length-1, new Vector3(0, 0, -1) + mesh.vertices[1]);
		}
	}














}
