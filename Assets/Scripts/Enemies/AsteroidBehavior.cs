using UnityEngine;
using System.Collections;



// Controls basic asteroid appearance and behavior
// Asteroid health and mass are always the same value.
// TODO: determine escape velocity and remove if too far
// TODO: Collide with projectiles
public class AsteroidBehavior : MonoBehaviour {


	public enum SizeClass {
		Small,
		Medium,
		Large,
		Larger
	};


	// These are the default sizes for the asteroids.
	static float[] masses = new float[]{
		25f,   // Small
		50f,   // Medium
		75f,   // Large
		100f,  // Larger
	};

	float mass;
	SizeClass size = SizeClass.Medium;
	Rigidbody  physicsBase;
	Mesh mesh;
	int numSpokes;
	Health health;
	float averageRadius;



	// The minimum size 
	static float minimumSize = 1.5f;

	// Controls how mass is interpreted sizewise.
	static float sizePerMass = 20.2f / 100f;

	


	// Whether or not the asteroid can be damaged
	public bool indestructable = false;


	public float initialRotation = 0f;
	public float initialRotationalVelocity = 0f;


	// Mesh generation variables
	public int minSpokes = 4;
	public int maxSpokes = 12;
	public float spokeHeightMin = 1f; 
	public float spokeHeightMax = 1f;

	//for items
	
	public float fuel_spawn_chance = 1f;
	public GameObject fuel_p1;
	public GameObject fuel_p2;

	


	void Awake() {

		physicsBase = GetComponent<Rigidbody>();
		mesh = GetComponent<MeshFilter>().mesh;
		health = GetComponent<Health>();
		health.registerDamageCallback(ReadjustSize);
		if (indestructable) health.invincible = true;

		transform.rotation = Quaternion.Euler(0, 0, initialRotation);
		rigidbody.AddTorque(0, 0, initialRotationalVelocity);
	}



	// Use this for initialization
	void Start () {

		 

		setSizeClass (size);

		numSpokes = (int)Random.Range(minSpokes, maxSpokes);

		physicsBase.mass = mass;
		health.init (mass, mass);


		generateMesh();

		ReadjustSize(gameObject);
		if (!indestructable)
			GetComponent<SphereCollider>().radius = averageRadius;
	}
	
	// Update is called once per frame
	void Update () {


	}

	










	/* Collisions */

	public void setSizeClass(SizeClass newSize) {
		size = newSize;
		mass = masses [(int)size];
	}


	// Called upon taking damage (via Health.registerDamageCallback())
	void ReadjustSize(GameObject h) {
		if (indestructable)
						return;

		if (health.isDead()) {
			
			
			float spawn_fuel = Random.value;
			if(spawn_fuel <= fuel_spawn_chance)
			{
				GameObject o = (GameObject)Instantiate (Random.value>.5f?fuel_p1 : fuel_p2);
				o.transform.position = transform.position;
				o.GetComponent<Rigidbody>().velocity = new Vector3 (1f, 2f, 0f);
			}
			
			Destroy (gameObject);
			return;
		}

		physicsBase.mass = health.current ();
		float healthRatio = (physicsBase.mass*sizePerMass) * averageRadius;
		float newScale =  healthRatio;
		if (newScale < minimumSize)
						newScale = minimumSize;


		transform.localScale  = new Vector3(newScale, newScale, newScale);


	}























	/* Mesh generation */


	// Generates the asteroid's random mesh
	void generateMesh() {

		mesh.Clear ();

		Vector3 [] newVertices = generateVertices(
			numSpokes,
			spokeHeightMin,
			spokeHeightMax

		);


		mesh.vertices  = newVertices;
		mesh.triangles = generateTriangles(newVertices.Length-1);
		mesh.uv =        generateTexCoords();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();

		// If you want true collisions, consider a MeshCollider, but be aware that Unity hates flat meshes
		//GetComponent<MeshCollider>().sharedMesh = mesh;




		// Optional, set the outline child object line renderer to be the border's highlights
		setOutline();

	}
	 

	// Generates an array of vertices that surround the centerpoint 0, 0
	// in a clockwise fashion. The points are placed uniformly around 0,0
	// at a random distance from minHeight to maxHeight. The length of the 
	// output Vertexd list is always 1 + numberOfPoints and the first element
	// is always 0, 0

	Vector3[] generateVertices(int numberOfDivisions, float minHeight, float maxHeight) {
		Vector3[] outVertices = new Vector3[numberOfDivisions+1];
		outVertices[0] = new Vector3(0, 0, 0);

		float nextRad;
		for (int i = 1; i < numberOfDivisions+1; ++i) {
			nextRad = Random.Range (minHeight, maxHeight);
			outVertices[i] = new Vector3(0, nextRad , 0);
			outVertices[i] = Quaternion.Euler(0, 0, (360.0f / (float)(numberOfDivisions))*i) * outVertices[i];
			averageRadius += nextRad;
		}
		averageRadius /= (float)numberOfDivisions;


		return outVertices;
	}


	// Generates triangles around the center based around the assumption that 
	// the vertices were generated by the generateVertices function
	int[] generateTriangles(int numVertices) {
		int[] tris = new int[numVertices*3];
		int vertexIndex = 1;

		for(int i = 0; i < numVertices; ++i) {
			tris[(i*3)+ 2] = 0;
			tris[(i*3)+ 1] = vertexIndex;
			tris[(i*3)+ 0] = vertexIndex+1;


			++vertexIndex;

		}

		tris[tris.Length-3] = 1;

		return tris;
	}


	// Generate proper texture coordinates based on vertices
	Vector2[] generateTexCoords() {
		Vector2[] outV = new Vector2[mesh.vertices.Length];
		for(int i = 0; i < mesh.vertices.Length; ++i) {
			outV[i] = new Vector2(mesh.vertices[i].x, mesh.vertices[i].y);
		}
		return outV;

	}






	void setOutline() {
		LineRenderer outline = GetComponentInChildren<LineRenderer>();
		if (outline) {
			outline.SetVertexCount(mesh.vertices.Length);
			outline.SetWidth(.03f, .03f);
			for(int i = 1; i < mesh.vertices.Length; ++i) {
				outline.SetPosition(i-1, new Vector3(0, 0, -1) + mesh.vertices[i]);
				
			}

			outline.SetPosition(mesh.vertices.Length-1, new Vector3(0, 0, -1) + mesh.vertices[1]);
		}
	}














}
